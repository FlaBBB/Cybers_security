import math
from Crypto.Util.number import getPrime, inverse, bytes_to_long, long_to_bytes


def gaussian_lattice_reduction(V1, V2):
    while True:
        if V2.norm() < V1.norm():
            V1, V2 = V2, V1
        m = round((V1 * V2) / (V1 * V1))
        if m == 0:
            return V1, V2
        V2 = V2 - m * V1


def decrypt(q, h, f, g, e):
    a = (f * e) % q
    m = (a * inverse(f, g)) % g
    return m


def crack(q, h):
    return gaussian_lattice_reduction(matrix([[1, h], [0, q]]))[0]


e = 5605696495253720664142881956908624307570671858477482119657436163663663844731169035682344974286379049123733356009125671924280312532755241162267269123486523
q, h = (
    7638232120454925879231554234011842347641017888219021175304217358715878636183252433454896490677496516149889316745664606749499241420160898019203925115292257,
    2163268902194560093843693572170199707501787797497998463462129592239973581462651622978282637513865274199374452805292639586264791317439029535926401109074800,
)

f, g = crack(q, h)

M = decrypt(q, h, f, g, e)
print(long_to_bytes(M))
