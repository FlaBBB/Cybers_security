/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_1020();
// int puts(const char *s);
// size_t strlen(const char *s);
// int printf(const char *format, ...);
// char *fgets(char *s, int n, FILE *stream);
// void __noreturn exit(int status);
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void));
FILE **sub_10C0();
__int64 sub_10F0(void); // weak
FILE **sub_1130();
__int64 sub_1180();
__int64 lightbulb();
unsigned __int64 __fastcall second_check(__int64 a1, int a2);
__int64 __fastcall applySignalProcessing(unsigned int signal, int flag, int ten);
__int64 __fastcall check(_DWORD *flag);
int __fastcall main(int argc, const char **argv, const char **envp);
void term_proc();
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);
// int __fastcall _cxa_finalize(void *);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

void *_dso_handle = &_dso_handle; // idb
FILE *_bss_start; // idb
char byte_6048; // weak


//----- (0000000000001000) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 60A0: using guessed type __int64 _gmon_start__(void);

//----- (0000000000001020) ----------------------------------------------------
void sub_1020()
{
  JUMPOUT(0LL);
}
// 1026: control flows out of bounds to 0

//----- (0000000000001090) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (__fastcall *)(int, char **, char **))main, v4, &retaddr, 0LL, 0LL, a3, &v5);
  __halt();
}
// 109A: positive sp value 8 has been found
// 10A1: variable 'v3' is possibly undefined

//----- (00000000000010C0) ----------------------------------------------------
FILE **sub_10C0()
{
  return &_bss_start;
}

//----- (00000000000010F0) ----------------------------------------------------
__int64 sub_10F0()
{
  return 0LL;
}
// 10F0: using guessed type __int64 sub_10F0();

//----- (0000000000001130) ----------------------------------------------------
FILE **sub_1130()
{
  FILE **result; // rax

  if ( !byte_6048 )
  {
    if ( &_cxa_finalize )
      _cxa_finalize(_dso_handle);
    result = sub_10C0();
    byte_6048 = 1;
  }
  return result;
}
// 6048: using guessed type char byte_6048;

//----- (0000000000001180) ----------------------------------------------------
// attributes: thunk
__int64 sub_1180()
{
  return sub_10F0();
}
// 10F0: using guessed type __int64 sub_10F0(void);

//----- (0000000000001189) ----------------------------------------------------
__int64 lightbulb()
{
  return 0LL;
}

//----- (00000000000011D3) ----------------------------------------------------
unsigned __int64 __fastcall second_check(__int64 a1, int a2)
{
  int v3; // [rsp+10h] [rbp-120h]
  int i; // [rsp+14h] [rbp-11Ch]
  int v5; // [rsp+18h] [rbp-118h]
  int j; // [rsp+1Ch] [rbp-114h]
  int v7; // [rsp+20h] [rbp-110h]
  int k; // [rsp+24h] [rbp-10Ch]
  int v9; // [rsp+28h] [rbp-108h]
  int m; // [rsp+2Ch] [rbp-104h]
  int v11; // [rsp+30h] [rbp-100h]
  int n; // [rsp+34h] [rbp-FCh]
  int v13; // [rsp+38h] [rbp-F8h]
  int ii; // [rsp+3Ch] [rbp-F4h]
  int v15; // [rsp+40h] [rbp-F0h]
  int jj; // [rsp+44h] [rbp-ECh]
  int v17; // [rsp+48h] [rbp-E8h]
  int kk; // [rsp+4Ch] [rbp-E4h]
  int v19; // [rsp+50h] [rbp-E0h]
  int mm; // [rsp+54h] [rbp-DCh]
  int total_correct; // [rsp+58h] [rbp-D8h]
  int nn; // [rsp+5Ch] [rbp-D4h]
  int cipher[50]; // [rsp+60h] [rbp-D0h]
  unsigned __int64 v24; // [rsp+128h] [rbp-8h]

  v24 = __readfsqword(0x28u);
  if ( a2 == 5 )
  {
    cipher[0] = 44;
    cipher[1] = 40;
    cipher[2] = 44;
    cipher[3] = 44;
    cipher[4] = 44;
    cipher[5] = 40;
    cipher[6] = 40;
    cipher[7] = 44;
    cipher[8] = 40;
    cipher[9] = 44;
    cipher[10] = 40;
    cipher[11] = 44;
    cipher[12] = 40;
    cipher[13] = 44;
    cipher[14] = 40;
    cipher[15] = 44;
    cipher[16] = 40;
    cipher[17] = 44;
    cipher[18] = 44;
    cipher[19] = 44;
    cipher[20] = 40;
    cipher[21] = 40;
    cipher[22] = 40;
    cipher[23] = 40;
    cipher[24] = 44;
    cipher[25] = 44;
    cipher[26] = 40;
    cipher[27] = 40;
    cipher[28] = 44;
    cipher[29] = 40;
    cipher[30] = 44;
    cipher[31] = 44;
    cipher[32] = 40;
    cipher[33] = 44;
    cipher[34] = 44;
    cipher[35] = 40;
    cipher[36] = 40;
    cipher[37] = 40;
    cipher[38] = 40;
    cipher[39] = 40;
    cipher[40] = 40;
    cipher[41] = 40;
    cipher[42] = 40;
    cipher[43] = 40;
    cipher[44] = 40;
    cipher[45] = 40;
    cipher[46] = 40;
    cipher[47] = 40;
    cipher[48] = 40;
    cipher[49] = 40;
    v3 = 0;
    for ( i = 0; i <= 49; ++i )
    {
      if ( cipher[i] == *(_DWORD *)(4LL * i + a1) )
        ++v3;
    }
    if ( v3 == 50 )
      lightbulb();
  }
  if ( a2 == 10 )
  {
    cipher[0] = 38430;
    cipher[1] = 35230;
    cipher[2] = 38430;
    cipher[3] = 38430;
    cipher[4] = 38430;
    cipher[5] = 35230;
    cipher[6] = 35230;
    cipher[7] = 38430;
    cipher[8] = 35230;
    cipher[9] = 38430;
    cipher[10] = 35230;
    cipher[11] = 38430;
    cipher[12] = 35230;
    cipher[13] = 38430;
    cipher[14] = 35230;
    cipher[15] = 38430;
    cipher[16] = 35230;
    cipher[17] = 38430;
    cipher[18] = 38430;
    cipher[19] = 38430;
    cipher[20] = 35230;
    cipher[21] = 35230;
    cipher[22] = 35230;
    cipher[23] = 35230;
    cipher[24] = 38430;
    cipher[25] = 38430;
    cipher[26] = 35230;
    cipher[27] = 35230;
    cipher[28] = 38430;
    cipher[29] = 35230;
    cipher[30] = 38430;
    cipher[31] = 38430;
    cipher[32] = 35230;
    cipher[33] = 38430;
    cipher[34] = 38430;
    cipher[35] = 35230;
    cipher[36] = 35230;
    cipher[37] = 35230;
    cipher[38] = 35230;
    cipher[39] = 35230;
    cipher[40] = 35230;
    cipher[41] = 35230;
    cipher[42] = 35230;
    cipher[43] = 35230;
    cipher[44] = 35230;
    cipher[45] = 35230;
    cipher[46] = 35230;
    cipher[47] = 35230;
    cipher[48] = 35230;
    cipher[49] = 35230;
    v5 = 0;
    for ( j = 0; j <= 49; ++j )
    {
      if ( cipher[j] == *(_DWORD *)(4LL * j + a1) )
        ++v5;
    }
    if ( v5 == 50 )
      lightbulb();
  }
  if ( a2 == 15 )
  {
    cipher[0] = 307450;
    cipher[1] = 281850;
    cipher[2] = 307450;
    cipher[3] = 307450;
    cipher[4] = 307450;
    cipher[5] = 281850;
    cipher[6] = 281850;
    cipher[7] = 307450;
    cipher[8] = 281850;
    cipher[9] = 307450;
    cipher[10] = 281850;
    cipher[11] = 307450;
    cipher[12] = 281850;
    cipher[13] = 307450;
    cipher[14] = 281850;
    cipher[15] = 307450;
    cipher[16] = 281850;
    cipher[17] = 307450;
    cipher[18] = 307450;
    cipher[19] = 307450;
    cipher[20] = 281850;
    cipher[21] = 281850;
    cipher[22] = 281850;
    cipher[23] = 281850;
    cipher[24] = 307450;
    cipher[25] = 307450;
    cipher[26] = 281850;
    cipher[27] = 281850;
    cipher[28] = 307450;
    cipher[29] = 281850;
    cipher[30] = 307450;
    cipher[31] = 307450;
    cipher[32] = 281850;
    cipher[33] = 307450;
    cipher[34] = 307450;
    cipher[35] = 281850;
    cipher[36] = 281850;
    cipher[37] = 281850;
    cipher[38] = 281850;
    cipher[39] = 281850;
    cipher[40] = 281850;
    cipher[41] = 281850;
    cipher[42] = 281850;
    cipher[43] = 281850;
    cipher[44] = 281850;
    cipher[45] = 281850;
    cipher[46] = 281850;
    cipher[47] = 281850;
    cipher[48] = 281850;
    cipher[49] = 281850;
    v7 = 0;
    for ( k = 0; k <= 49; ++k )
    {
      if ( cipher[k] == *(_DWORD *)(4LL * k + a1) )
        ++v7;
    }
    if ( v7 == 50 )
      lightbulb();
  }
  if ( a2 == 20 )
  {
    cipher[0] = 307470;
    cipher[1] = 281870;
    cipher[2] = 307470;
    cipher[3] = 307470;
    cipher[4] = 307470;
    cipher[5] = 281870;
    cipher[6] = 281870;
    cipher[7] = 307470;
    cipher[8] = 281870;
    cipher[9] = 307470;
    cipher[10] = 281870;
    cipher[11] = 307470;
    cipher[12] = 281870;
    cipher[13] = 307470;
    cipher[14] = 281870;
    cipher[15] = 307470;
    cipher[16] = 281870;
    cipher[17] = 307470;
    cipher[18] = 307470;
    cipher[19] = 307470;
    cipher[20] = 281870;
    cipher[21] = 281870;
    cipher[22] = 281870;
    cipher[23] = 281870;
    cipher[24] = 307470;
    cipher[25] = 307470;
    cipher[26] = 281870;
    cipher[27] = 281870;
    cipher[28] = 307470;
    cipher[29] = 281870;
    cipher[30] = 307470;
    cipher[31] = 307470;
    cipher[32] = 281870;
    cipher[33] = 307470;
    cipher[34] = 307470;
    cipher[35] = 281870;
    cipher[36] = 281870;
    cipher[37] = 281870;
    cipher[38] = 281870;
    cipher[39] = 281870;
    cipher[40] = 281870;
    cipher[41] = 281870;
    cipher[42] = 281870;
    cipher[43] = 281870;
    cipher[44] = 281870;
    cipher[45] = 281870;
    cipher[46] = 281870;
    cipher[47] = 281870;
    cipher[48] = 281870;
    cipher[49] = 281870;
    v9 = 0;
    for ( m = 0; m <= 49; ++m )
    {
      if ( cipher[m] == *(_DWORD *)(4LL * m + a1) )
        ++v9;
    }
    if ( v9 == 50 )
      lightbulb();
  }
  if ( a2 == 25 )
  {
    cipher[0] = 307450;
    cipher[1] = 281850;
    cipher[2] = 307450;
    cipher[3] = 307450;
    cipher[4] = 307450;
    cipher[5] = 281850;
    cipher[6] = 281850;
    cipher[7] = 307450;
    cipher[8] = 281850;
    cipher[9] = 307450;
    cipher[10] = 281850;
    cipher[11] = 307450;
    cipher[12] = 281850;
    cipher[13] = 307450;
    cipher[14] = 281850;
    cipher[15] = 307450;
    cipher[16] = 281850;
    cipher[17] = 307450;
    cipher[18] = 307450;
    cipher[19] = 307450;
    cipher[20] = 281850;
    cipher[21] = 281850;
    cipher[22] = 281850;
    cipher[23] = 281850;
    cipher[24] = 307450;
    cipher[25] = 307450;
    cipher[26] = 281850;
    cipher[27] = 281850;
    cipher[28] = 307450;
    cipher[29] = 281850;
    cipher[30] = 307450;
    cipher[31] = 307450;
    cipher[32] = 281850;
    cipher[33] = 307450;
    cipher[34] = 307450;
    cipher[35] = 281850;
    cipher[36] = 281850;
    cipher[37] = 281850;
    cipher[38] = 281850;
    cipher[39] = 281850;
    cipher[40] = 281850;
    cipher[41] = 281850;
    cipher[42] = 281850;
    cipher[43] = 281850;
    cipher[44] = 281850;
    cipher[45] = 281850;
    cipher[46] = 281850;
    cipher[47] = 281850;
    cipher[48] = 281850;
    cipher[49] = 281850;
    v11 = 0;
    for ( n = 0; n <= 49; ++n )
    {
      if ( cipher[n] == *(_DWORD *)(4LL * n + a1) )
        ++v11;
    }
    if ( v11 == 50 )
      lightbulb();
  }
  if ( a2 == 30 )
  {
    cipher[0] = 2460032;
    cipher[1] = 2255232;
    cipher[2] = 2460032;
    cipher[3] = 2460032;
    cipher[4] = 2460032;
    cipher[5] = 2255232;
    cipher[6] = 2255232;
    cipher[7] = 2460032;
    cipher[8] = 2255232;
    cipher[9] = 2460032;
    cipher[10] = 2255232;
    cipher[11] = 2460032;
    cipher[12] = 2255232;
    cipher[13] = 2460032;
    cipher[14] = 2255232;
    cipher[15] = 2460032;
    cipher[16] = 2255232;
    cipher[17] = 2460032;
    cipher[18] = 2460032;
    cipher[19] = 2460032;
    cipher[20] = 2255232;
    cipher[21] = 2255232;
    cipher[22] = 2255232;
    cipher[23] = 2255232;
    cipher[24] = 2460032;
    cipher[25] = 2460032;
    cipher[26] = 2255232;
    cipher[27] = 2255232;
    cipher[28] = 2460032;
    cipher[29] = 2255232;
    cipher[30] = 2460032;
    cipher[31] = 2460032;
    cipher[32] = 2255232;
    cipher[33] = 2460032;
    cipher[34] = 2460032;
    cipher[35] = 2255232;
    cipher[36] = 2255232;
    cipher[37] = 2255232;
    cipher[38] = 2255232;
    cipher[39] = 2255232;
    cipher[40] = 2255232;
    cipher[41] = 2255232;
    cipher[42] = 2255232;
    cipher[43] = 2255232;
    cipher[44] = 2255232;
    cipher[45] = 2255232;
    cipher[46] = 2255232;
    cipher[47] = 2255232;
    cipher[48] = 2255232;
    cipher[49] = 2255232;
    v13 = 0;
    for ( ii = 0; ii <= 49; ++ii )
    {
      if ( cipher[ii] == *(_DWORD *)(4LL * ii + a1) )
        ++v13;
    }
    if ( v13 == 50 )
      lightbulb();
  }
  if ( a2 == 35 )
  {
    cipher[0] = 49000;
    cipher[1] = 44900;
    cipher[2] = 49000;
    cipher[3] = 49000;
    cipher[4] = 49000;
    cipher[5] = 44900;
    cipher[6] = 44900;
    cipher[7] = 49000;
    cipher[8] = 44900;
    cipher[9] = 49000;
    cipher[10] = 44900;
    cipher[11] = 49000;
    cipher[12] = 44900;
    cipher[13] = 49000;
    cipher[14] = 44900;
    cipher[15] = 49000;
    cipher[16] = 44900;
    cipher[17] = 49000;
    cipher[18] = 49000;
    cipher[19] = 49000;
    cipher[20] = 44900;
    cipher[21] = 44900;
    cipher[22] = 44900;
    cipher[23] = 44900;
    cipher[24] = 49000;
    cipher[25] = 49000;
    cipher[26] = 44900;
    cipher[27] = 44900;
    cipher[28] = 49000;
    cipher[29] = 44900;
    cipher[30] = 49000;
    cipher[31] = 49000;
    cipher[32] = 44900;
    cipher[33] = 49000;
    cipher[34] = 49000;
    cipher[35] = 44900;
    cipher[36] = 44900;
    cipher[37] = 44900;
    cipher[38] = 44900;
    cipher[39] = 44900;
    cipher[40] = 44900;
    cipher[41] = 44900;
    cipher[42] = 44900;
    cipher[43] = 44900;
    cipher[44] = 44900;
    cipher[45] = 44900;
    cipher[46] = 44900;
    cipher[47] = 44900;
    cipher[48] = 44900;
    cipher[49] = 44900;
    v15 = 0;
    for ( jj = 0; jj <= 49; ++jj )
    {
      if ( cipher[jj] == *(_DWORD *)(4LL * jj + a1) )
        ++v15;
    }
    if ( v15 == 50 )
      lightbulb();
  }
  if ( a2 == 40 )
  {
    cipher[0] = 48990;
    cipher[1] = 44890;
    cipher[2] = 48990;
    cipher[3] = 48990;
    cipher[4] = 48990;
    cipher[5] = 44890;
    cipher[6] = 44890;
    cipher[7] = 48990;
    cipher[8] = 44890;
    cipher[9] = 48990;
    cipher[10] = 44890;
    cipher[11] = 48990;
    cipher[12] = 44890;
    cipher[13] = 48990;
    cipher[14] = 44890;
    cipher[15] = 48990;
    cipher[16] = 44890;
    cipher[17] = 48990;
    cipher[18] = 48990;
    cipher[19] = 48990;
    cipher[20] = 44890;
    cipher[21] = 44890;
    cipher[22] = 44890;
    cipher[23] = 44890;
    cipher[24] = 48990;
    cipher[25] = 48990;
    cipher[26] = 44890;
    cipher[27] = 44890;
    cipher[28] = 48990;
    cipher[29] = 44890;
    cipher[30] = 48990;
    cipher[31] = 48990;
    cipher[32] = 44890;
    cipher[33] = 48990;
    cipher[34] = 48990;
    cipher[35] = 44890;
    cipher[36] = 44890;
    cipher[37] = 44890;
    cipher[38] = 44890;
    cipher[39] = 44890;
    cipher[40] = 44890;
    cipher[41] = 44890;
    cipher[42] = 44890;
    cipher[43] = 44890;
    cipher[44] = 44890;
    cipher[45] = 44890;
    cipher[46] = 44890;
    cipher[47] = 44890;
    cipher[48] = 44890;
    cipher[49] = 44890;
    v17 = 0;
    for ( kk = 0; kk <= 49; ++kk )
    {
      if ( cipher[kk] == *(_DWORD *)(4LL * kk + a1) )
        ++v17;
    }
    if ( v17 == 50 )
      lightbulb();
  }
  if ( a2 == 45 )
  {
    cipher[0] = 392080;
    cipher[1] = 359280;
    cipher[2] = 392080;
    cipher[3] = 392080;
    cipher[4] = 392080;
    cipher[5] = 359280;
    cipher[6] = 359280;
    cipher[7] = 392080;
    cipher[8] = 359280;
    cipher[9] = 392080;
    cipher[10] = 359280;
    cipher[11] = 392080;
    cipher[12] = 359280;
    cipher[13] = 392080;
    cipher[14] = 359280;
    cipher[15] = 392080;
    cipher[16] = 359280;
    cipher[17] = 392080;
    cipher[18] = 392080;
    cipher[19] = 392080;
    cipher[20] = 359280;
    cipher[21] = 359280;
    cipher[22] = 359280;
    cipher[23] = 359280;
    cipher[24] = 392080;
    cipher[25] = 392080;
    cipher[26] = 359280;
    cipher[27] = 359280;
    cipher[28] = 392080;
    cipher[29] = 359280;
    cipher[30] = 392080;
    cipher[31] = 392080;
    cipher[32] = 359280;
    cipher[33] = 392080;
    cipher[34] = 392080;
    cipher[35] = 359280;
    cipher[36] = 359280;
    cipher[37] = 359280;
    cipher[38] = 359280;
    cipher[39] = 359280;
    cipher[40] = 359280;
    cipher[41] = 359280;
    cipher[42] = 359280;
    cipher[43] = 359280;
    cipher[44] = 359280;
    cipher[45] = 359280;
    cipher[46] = 359280;
    cipher[47] = 359280;
    cipher[48] = 359280;
    cipher[49] = 359280;
    v19 = 0;
    for ( mm = 0; mm <= 49; ++mm )
    {
      if ( cipher[mm] == *(_DWORD *)(4LL * mm + a1) )
        ++v19;
    }
    if ( v19 == 50 )
      lightbulb();
  }
  if ( a2 == 50 )
  {
    cipher[0] = 784212;
    cipher[1] = 718612;
    cipher[2] = 784212;
    cipher[3] = 784212;
    cipher[4] = 784212;
    cipher[5] = 718612;
    cipher[6] = 718612;
    cipher[7] = 784212;
    cipher[8] = 718612;
    cipher[9] = 784212;
    cipher[10] = 718612;
    cipher[11] = 784212;
    cipher[12] = 718612;
    cipher[13] = 784212;
    cipher[14] = 718612;
    cipher[15] = 784212;
    cipher[16] = 718612;
    cipher[17] = 784212;
    cipher[18] = 784212;
    cipher[19] = 784212;
    cipher[20] = 718612;
    cipher[21] = 718612;
    cipher[22] = 718612;
    cipher[23] = 718612;
    cipher[24] = 784212;
    cipher[25] = 784212;
    cipher[26] = 718612;
    cipher[27] = 718612;
    cipher[28] = 784212;
    cipher[29] = 718612;
    cipher[30] = 784212;
    cipher[31] = 784212;
    cipher[32] = 718612;
    cipher[33] = 784212;
    cipher[34] = 784212;
    cipher[35] = 718612;
    cipher[36] = 718612;
    cipher[37] = 718612;
    cipher[38] = 718612;
    cipher[39] = 718612;
    cipher[40] = 718612;
    cipher[41] = 718612;
    cipher[42] = 718612;
    cipher[43] = 718612;
    cipher[44] = 718612;
    cipher[45] = 718612;
    cipher[46] = 718612;
    cipher[47] = 718612;
    cipher[48] = 718612;
    cipher[49] = 718612;
    total_correct = 0;
    for ( nn = 0; nn <= 49; ++nn )
    {
      if ( cipher[nn] == *(_DWORD *)(4LL * nn + a1) )
        ++total_correct;
    }
    if ( total_correct == 50 )
    {
      puts("Congrats, that's the correct flag!");
      lightbulb();
    }
  }
  return v24 - __readfsqword(0x28u);
}
// 1189: using guessed type __int64 lightbulb(void);

//----- (00000000000026FC) ----------------------------------------------------
__int64 __fastcall applySignalProcessing(unsigned int signal, int flag, int ten)
{
  __int64 result; // rax

  switch ( flag )
  {
    case 20:
      result = signal;
      break;
    case 23:
      result = 8 * signal;
      break;
    case 26:
      result = 3 * ten + signal;
      break;
    case 29:
      if ( (int)signal <= 1000 )
        result = ten * ten * signal;
      else
        result = signal;
      break;
    case 32:
      result = ten ^ signal;
      break;
    case 35:
      if ( (int)signal <= 1000000 )
        goto LABEL_11;
      result = (unsigned int)((int)signal / 1000);
      break;
    case 38:
LABEL_11:
      if ( (int)signal <= ten )
        result = signal;
      else
        result = signal - ten;
      break;
    case 41:
      if ( (int)signal <= 10000 )
        result = ten * signal;
      else
        result = signal;
      break;
    case 44:
      result = 2 * signal;
      break;
    case 47:
      result = signal + ten;
      break;
    default:
      result = 0LL;
      break;
  }
  return result;
}

//----- (00000000000027ED) ----------------------------------------------------
__int64 __fastcall check(_DWORD *flag)
{
  __int64 result; // rax

  if ( (flag[3] ^ flag[2] ^ flag[1] ^ *flag ^ flag[4]) != 44 )
    exit(0);
  if ( (flag[8] ^ flag[7] ^ flag[6] ^ flag[5] ^ flag[9]) != 31 )
    exit(0);
  if ( (flag[13] ^ flag[12] ^ flag[11] ^ flag[10] ^ flag[14]) != 29 )
    exit(0);
  if ( (flag[18] ^ flag[17] ^ flag[16] ^ flag[15] ^ flag[19]) != 20 )
    exit(0);
  if ( (flag[23] ^ flag[22] ^ flag[21] ^ flag[20] ^ flag[24]) != 29 )
    exit(0);
  if ( (flag[28] ^ flag[27] ^ flag[26] ^ flag[25] ^ flag[29]) != 42 )
    exit(0);
  if ( (flag[33] ^ flag[32] ^ flag[31] ^ flag[30] ^ flag[34]) != 31 )
    exit(0);
  if ( (flag[38] ^ flag[37] ^ flag[36] ^ flag[35] ^ flag[39]) != 47 )
    exit(0);
  if ( (flag[43] ^ flag[42] ^ flag[41] ^ flag[40] ^ flag[44]) != 43 )
    exit(0);
  if ( (flag[48] ^ flag[47] ^ flag[46] ^ flag[45] ^ flag[49]) != 42 )
    exit(0);
  if ( *flag != 32 )
    exit(0);
  if ( flag[5] != 32 )
    exit(0);
  if ( flag[10] != 23 )
    exit(0);
  if ( flag[15] != 41 )
    exit(0);
  if ( flag[20] != 35 )
    exit(0);
  if ( flag[25] != 26 )
    exit(0);
  if ( flag[30] != 26 )
    exit(0);
  if ( flag[35] != 29 )
    exit(0);
  if ( flag[40] != 26 )
    exit(0);
  if ( flag[45] != 38 )
    exit(0);
  if ( flag[4] != 47 )
    exit(0);
  if ( flag[9] != 26 )
    exit(0);
  if ( flag[14] != 47 )
    exit(0);
  if ( flag[19] != 47 )
    exit(0);
  if ( flag[24] != 41 )
    exit(0);
  if ( flag[29] != 29 )
    exit(0);
  if ( flag[34] != 44 )
    exit(0);
  if ( flag[39] != 29 )
    exit(0);
  if ( flag[44] != 20 )
    exit(0);
  result = (unsigned int)flag[49];
  if ( (_DWORD)result != 26 )
    exit(0);
  return result;
}

//----- (0000000000002CF5) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  void *v3; // rsp
  int v4; // eax
  int i; // [rsp+0h] [rbp-240h] BYREF
  int j; // [rsp+4h] [rbp-23Ch]
  int k; // [rsp+8h] [rbp-238h]
  int flag_len; // [rsp+Ch] [rbp-234h]
  __int64 v10; // [rsp+10h] [rbp-230h]
  int *_flag; // [rsp+18h] [rbp-228h]
  int xorerr[52]; // [rsp+20h] [rbp-220h]
  int v13[52]; // [rsp+F0h] [rbp-150h] BYREF
  char flag[104]; // [rsp+1C0h] [rbp-80h] BYREF
  unsigned __int64 v15; // [rsp+228h] [rbp-18h]

  v15 = __readfsqword(0x28u);
  puts("Welcome to my calculator !!! \n");
  printf("Please enter the flag: ");
  fgets(flag, 100, _bss_start);
  flag_len = strlen(flag) - 1;
  xorerr[0] = 83;
  xorerr[1] = 68;
  xorerr[2] = 77;
  xorerr[3] = 72;
  xorerr[4] = 91;
  xorerr[5] = 73;
  xorerr[6] = 76;
  xorerr[7] = 99;
  xorerr[8] = 123;
  xorerr[9] = 97;
  xorerr[10] = 36;
  xorerr[11] = 69;
  xorerr[12] = 16;
  xorerr[13] = 76;
  xorerr[14] = 91;
  xorerr[15] = 91;
  xorerr[16] = 31;
  xorerr[17] = 122;
  xorerr[18] = 24;
  xorerr[19] = 76;
  xorerr[20] = 80;
  xorerr[21] = 124;
  xorerr[22] = 110;
  xorerr[23] = 25;
  xorerr[24] = 68;
  xorerr[25] = 41;
  xorerr[26] = 84;
  xorerr[27] = 43;
  xorerr[28] = 122;
  xorerr[29] = 46;
  xorerr[30] = 105;
  xorerr[31] = 124;
  xorerr[32] = 18;
  xorerr[33] = 90;
  xorerr[34] = 115;
  xorerr[35] = 109;
  xorerr[36] = 27;
  xorerr[37] = 18;
  xorerr[38] = 77;
  xorerr[39] = 66;
  xorerr[40] = 45;
  xorerr[41] = 21;
  xorerr[42] = 33;
  xorerr[43] = 37;
  xorerr[44] = 45;
  xorerr[45] = 18;
  xorerr[46] = 23;
  xorerr[47] = 25;
  xorerr[48] = 34;
  xorerr[49] = 103;
  v10 = flag_len - 1LL;
  v3 = alloca(16 * ((4LL * flag_len + 15) / 16uLL));
  _flag = &i;
  for ( i = 0; i < flag_len; ++i )
    _flag[i] = flag[i] ^ xorerr[i];
  check(_flag);
  memset(v13, 0, 200uLL);
  v13[0] = 1;
  v13[2] = 1;
  v13[3] = 1;
  v13[4] = 1;
  v13[7] = 1;
  v13[9] = 1;
  v13[11] = 1;
  v13[13] = 1;
  v13[15] = 1;
  v13[17] = 1;
  v13[18] = 1;
  v13[19] = 1;
  v13[24] = 1;
  v13[25] = 1;
  v13[28] = 1;
  v13[30] = 1;
  v13[31] = 1;
  v13[33] = 1;
  v13[34] = 1;
  for ( j = 0; j < flag_len; ++j )
  {
    for ( k = 0; k <= 49; ++k )
    {
      v4 = applySignalProcessing(v13[k], _flag[j], 10);
      v13[k] = v4;
    }
    if ( !((j + 1) % 5) )
      second_check((__int64)v13, j + 1);
  }
  return 0;
}
// 2CF5: using guessed type char flag[104];

//----- (00000000000031E4) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=28 queued=13 decompiled=13 lumina nreq=0 worse=0 better=0
// ALL OK, 13 function(s) have been successfully decompiled
