

# This file was *autogenerated* from the file Cryptography/apostle/solve-r.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_2 = Integer(2); _sage_const_8 = Integer(8); _sage_const_3 = Integer(3); _sage_const_7 = Integer(7); _sage_const_5 = Integer(5); _sage_const_6 = Integer(6); _sage_const_11 = Integer(11); _sage_const_256 = Integer(256); _sage_const_16 = Integer(16); _sage_const_12 = Integer(12); _sage_const_15 = Integer(15); _sage_const_9 = Integer(9); _sage_const_14 = Integer(14); _sage_const_13 = Integer(13); _sage_const_10 = Integer(10)# # AES 1 round 1 data attacks

# First, AES boilerplate and generate subkeys, plaintext and ciphertext.

from sage.all import *
import aes
from hashlib import md5

A = aes

key = list(md5(b"key key").digest())
expkey = A.expandKey(key, _sage_const_1 )
rk1 = transpose(expkey[_sage_const_0 ])
rk2 = transpose(expkey[_sage_const_0 ])
rkp = A.mixColumns(rk2[::], True)

pt = list(md5(b"plaintext").digest())

ct = list(pt)
ct = A.addRoundKey(ct[::], rk1)
ct = A.subBytes(ct[::], False)
ct = A.shiftRows(ct[::], False)

if _sage_const_0 : # equivalent
    ct = A.addRoundKey(ct[::], rkp)
    ct = A.mixColumns(ct[::], False)
else:
    ct = A.mixColumns(ct[::], False)
    ct = A.addRoundKey(ct[::], rk2)

print("pt", pt)
print("key", key)
print("ct", ct)
print("rk1", rk1)
print("rk2", rk2)

ctp = A.mixColumns(ct[::], True)

def backward(i):
    y = i // _sage_const_4 
    x = (i + y) % _sage_const_4 
    j = y*_sage_const_4  + x
    k[j] = A.rsbox[ctp[i] ^ kp[i]] ^ pt[j]

def forward(i):
    y = i // _sage_const_4 
    x = (i - y) % _sage_const_4 
    j = y*_sage_const_4  + x
    kp[j] = A.sbox[pt[i] ^ k[i]] ^ ctp[j]

def xor(a, b):
    return [aa ^ bb for aa, bb in zip(a, b)]

R = GF(_sage_const_2 )['x']; (x,) = R._first_ngens(1)
F = GF(_sage_const_2 **_sage_const_8 , name='a', modulus=x**_sage_const_8 +x**_sage_const_4 +x**_sage_const_3 +x+_sage_const_1 )
MC = matrix(F, _sage_const_4 , _sage_const_4 , [F.fetch_int(a) for a in [_sage_const_2 ,_sage_const_3 ,_sage_const_1 ,_sage_const_1 ,  _sage_const_1 ,_sage_const_2 ,_sage_const_3 ,_sage_const_1 ,   _sage_const_1 ,_sage_const_1 ,_sage_const_2 ,_sage_const_3 ,   _sage_const_3 ,_sage_const_1 ,_sage_const_1 ,_sage_const_2 ]])

def MC_permuted(perm):
    C = copy(identity_matrix(F, _sage_const_4 ).augment(~MC))
    C.permute_columns(Permutation([i + _sage_const_1  for i in perm]))  # sage permutations indexed from 1! argh
    return copy(C.echelon_form())

def mat_mul(mat, v):
    v = [F.fetch_int(a) for a in v]
    v = mat * vector(v)
    v = [a.integer_representation() for a in v]
    return v

# Method: guess $k'_1$ and one extra byte (5 total) to work with $k_0$ and $w$.

# precompute magic matrices
M1 = MC_permuted([_sage_const_0 , _sage_const_1 , _sage_const_4 , _sage_const_7 ,  _sage_const_2 , _sage_const_3 , _sage_const_5 , _sage_const_6 ])[:,_sage_const_4 :]

# precomputation from pt/ct
# cond 1: x + a * y = b
# cond 2: S[y] ^ t = Sinv(z ^ ctp[ci]) ^ pt[pi]
from collections import defaultdict
fa = F.fetch_int(_sage_const_11 )
precomp = defaultdict(list)
for b in range(_sage_const_256 ):
    fb = F.fetch_int(b)
    xys = []
    for y in range(_sage_const_256 ):
        fy = F.fetch_int(y)
        fx = fb - fa * fy
        x = fx.integer_representation()
        xys.append((x, y))
    for x, y in xys:
        t = A.rsbox[x ^ ctp[_sage_const_7 ]] ^ pt[_sage_const_4 ] ^ A.sbox[y]
        precomp[b,t].append((x, y))
        
print("precomp ok")

# subkey recovery progress
k = [None] * _sage_const_16 
kp = [None] * _sage_const_16 

# guesses (5 bytes)
kp[::_sage_const_4 ] = rkp[::_sage_const_4 ]
kp[_sage_const_3 ] = rkp[_sage_const_3 ]

# work out
# step 1: use single S-Boxes
backward(_sage_const_0 )
backward(_sage_const_3 )
backward(_sage_const_4 )
backward(_sage_const_8 )
backward(_sage_const_12 )

# step 2: use K0 and w relation
k0t = A.mixColumn(kp[::_sage_const_4 ], False)

k[_sage_const_7 ] = A.rsbox[k[_sage_const_0 ] ^ k0t[_sage_const_0 ] ^ _sage_const_1 ]
k[_sage_const_8 ] = A.sbox[k[_sage_const_15 ]] ^ k0t[_sage_const_2 ]
k[_sage_const_12 ] = A.sbox[k[_sage_const_3 ]] ^ k0t[_sage_const_3 ]
forward(_sage_const_7 )
forward(_sage_const_8 )
forward(_sage_const_12 )

# step 3: guess 1 and filter 1 at the same time via precomp
fb  = F.fetch_int(_sage_const_9 ) * F.fetch_int(k[_sage_const_3 ])
fb += F.fetch_int(_sage_const_14 ) * F.fetch_int(k[_sage_const_7 ])
fb += F.fetch_int(_sage_const_13 ) * F.fetch_int(k[_sage_const_15 ])
fb += F.fetch_int(kp[_sage_const_6 ])
b = fb.integer_representation()

for x, y in precomp[b,k0t[_sage_const_1 ]]:
    print("x fixed", x, "y", y)
    k[_sage_const_11 ] = y
    k[_sage_const_4 ] = A.sbox[k[_sage_const_11 ]] ^ k0t[_sage_const_1 ]
    kp[_sage_const_7 ] = x
    forward(_sage_const_4 )
    forward(_sage_const_11 )
    backward(_sage_const_7 )
    
    delta_kp23 = A.mixColumn([k[_sage_const_3 ], k[_sage_const_7 ], k[_sage_const_11 ], k[_sage_const_15 ]], True)
    
    kp[_sage_const_2 ] = delta_kp23[_sage_const_0 ] ^ kp[_sage_const_3 ]
    assert kp[_sage_const_7 ] == delta_kp23[_sage_const_1 ] ^ kp[_sage_const_6 ]
    kp[_sage_const_11 ] = delta_kp23[_sage_const_2 ] ^ kp[_sage_const_10 ]
    backward(_sage_const_2 )
    backward(_sage_const_11 )
    
    sol = mat_mul(M1, [kp[_sage_const_8 ]^kp[_sage_const_9 ], kp[_sage_const_12 ]^kp[_sage_const_13 ], k[_sage_const_5 ], k[_sage_const_9 ]])
    kp[_sage_const_1 ] = kp[_sage_const_0 ] ^ sol[_sage_const_0 ]
    kp[_sage_const_5 ] = kp[_sage_const_4 ] ^ sol[_sage_const_1 ]
    k[_sage_const_13 ] = sol[_sage_const_3 ]
    backward(_sage_const_1 )
    backward(_sage_const_5 )
    forward(_sage_const_13 )
    if k[_sage_const_1 ] != sol[_sage_const_2 ]:  # filter
        continue
    kp[_sage_const_15 ] = delta_kp23[_sage_const_3 ] ^ kp[_sage_const_14 ]
    backward(_sage_const_15 ) 
    break
else:
    print("failed")
    raise
    
assert k == rk1
assert kp == rkp

print("WIN!")

