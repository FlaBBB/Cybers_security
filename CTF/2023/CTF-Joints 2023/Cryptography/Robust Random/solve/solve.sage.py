

# This file was *autogenerated* from the file solve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_200 = Integer(200); _sage_const_2979367707659603116523387035539295735026485376436807443084845278516127174929783019392967820185018635850079566349868983092853995552241574450881758637291247 = Integer(2979367707659603116523387035539295735026485376436807443084845278516127174929783019392967820185018635850079566349868983092853995552241574450881758637291247); _sage_const_1170023119885859101024387880045520537874087001683337675848090433661429128088166458798239305574743731841113872001902781327295181878803694961875127813114856 = Integer(1170023119885859101024387880045520537874087001683337675848090433661429128088166458798239305574743731841113872001902781327295181878803694961875127813114856); _sage_const_13380037624452997384558524852608866433273618414151667350982539548293385222637966469911875057641453772347655559134636498494634474259294446532131041568362471 = Integer(13380037624452997384558524852608866433273618414151667350982539548293385222637966469911875057641453772347655559134636498494634474259294446532131041568362471); _sage_const_2 = Integer(2); _sage_const_512 = Integer(512); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3); _sage_const_0 = Integer(0); _sage_const_16 = Integer(16)
from Cryptodome.Util.number import *
from Cryptodome.Cipher import AES
from Cryptodome.Util.Padding import unpad

from hashlib import sha256

kbits = _sage_const_200 

x = _sage_const_2979367707659603116523387035539295735026485376436807443084845278516127174929783019392967820185018635850079566349868983092853995552241574450881758637291247 
c2 = _sage_const_1170023119885859101024387880045520537874087001683337675848090433661429128088166458798239305574743731841113872001902781327295181878803694961875127813114856 
p = _sage_const_13380037624452997384558524852608866433273618414151667350982539548293385222637966469911875057641453772347655559134636498494634474259294446532131041568362471 
iv = bytes.fromhex('8c1d85feea24c3145ace02cb86c79e07')
ct = bytes.fromhex('732c41662a780f0d7784d2d91845556cb258a5f413c218e9f5618d9d5eada1d7356c755eb121e25ee3d9299b2039a45b')

y = (p^x) & ((_sage_const_2 **(_sage_const_512 -kbits)-_sage_const_1 ) << kbits)
C = (c2 - x*y - y) % p
N = p

def check(M):
  for m in M:
    if m[_sage_const_3 ] == _sage_const_0  and m[_sage_const_0 ] > _sage_const_0  and m[_sage_const_0 ] < _sage_const_2 **_sage_const_200 :
      return True, m[_sage_const_0 ], m[_sage_const_1 ]
  return False, _sage_const_0 , _sage_const_0 

for k in range(_sage_const_1 ,_sage_const_200 ):
    w = _sage_const_2 **k #weight
    m = [[_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,w*x], [_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,w], [_sage_const_0 ,_sage_const_0 ,w,w*C], [_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,w*N]]
    n = len(m)
    M = Matrix(ZZ, n)
    for i in range(n):
      for j in range(n):
        M[i, j] = m[i][j]
    L = M.LLL() 
    if check(L)[_sage_const_0 ]:
      print(k)
      X, Y = check(L)[_sage_const_1 ], check(L)[_sage_const_2 ]
      break

a = X + y
b = Y + y

key = sha256(long_to_bytes(a) + long_to_bytes(b)).digest()[:_sage_const_16 ]
cipher = AES.new(key, AES.MODE_CBC, iv)
flag = unpad(cipher.decrypt(ct),_sage_const_16 )
print(flag)

